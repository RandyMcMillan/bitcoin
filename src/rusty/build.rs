// client/build.rs

extern crate cbindgen;

use cbindgen::Config;
use std::env;
use std::path::PathBuf;

const LICENSE: &'static str = "// Autogenerated Header File from Rust Source
// Copyright (c) 2009-2019 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.";

fn main() {
    // either read from $LIBNAME_H the header file, or
    // set it equal to $TARGET/$(CARGO_PKG_NAME).hpp
    let header_file_name = env::var("HEADER_FILE_OVERRIDE")
        .or(env::var("CARGO_PKG_NAME").map(|f| {
            target_dir()
                .join(format!("{}.hpp", f))
                .display()
                .to_string()
        }))
        .unwrap();

    // let the namespace either be read from $LIBNAME_H_NAMESPACE
    // or let it be set as the $(CARGO_PKG_NAME)_ffi
    let namespace = Some(
        env::var("NAMESPACE_OVERRIDE")
            .unwrap_or_else(|_| env::var("CARGO_PKG_NAME").map(|f| f + "_ffi").unwrap()),
    );

    let include_guard = Some({
        let mut i = String::from("BITCOIN_") + &env::var("CARGO_PKG_NAME").unwrap() + "_H";
        i.make_ascii_uppercase();
        i
    });
    let config = Config {
        header: Some(String::from(LICENSE)),
        namespace,
        include_guard,
        ..Default::default()
    };

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    cbindgen::generate_with_config(&crate_dir, config)
        .unwrap()
        .write_to_file(&header_file_name);
}

/// Find the location of the `target/` directory.
fn target_dir() -> PathBuf {
    env::var("HEADER_TARGET_DIR_OVERRIDE")
        .or(env::var("CARGO_TARGET_DIR"))
        .map(PathBuf::from)
        .unwrap_or_else(|_| {
            PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("target")
        })
}
